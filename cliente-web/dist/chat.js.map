{"version":3,"file":"chat.js","mappings":"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","sources":["webpack://cliente-web/./src/chat.js"],"sourcesContent":["class ChatApp {\r\n    constructor() {\r\n        this.username = '';\r\n        this.targetUser = '';\r\n        this.isGroupChat = false;\r\n        this.colors = [\r\n            '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7',\r\n            '#DDA0DD', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E9'\r\n        ];\r\n        this.API_URL = 'http://localhost:3000';\r\n        this.WS_URL = 'ws://localhost:3000';\r\n        this.ws = null;\r\n        this.isRecording = false;\r\n        this.mediaRecorder = null;\r\n        this.audioChunks = [];\r\n        this.isInCall = false;\r\n        this.localStream = null;\r\n        this.remoteStream = null;\r\n        this.reconnectAttempts = 0;\r\n        this.maxReconnectAttempts = 5;\r\n\r\n        // === WebRTC ===\r\n        this.peerConnection = null;\r\n        this.currentCallId = null;\r\n        this.pendingCandidates = [];\r\n        this.callPeer = null; // Usuario con el que estamos en llamada\r\n        \r\n        // ConfiguraciÃ³n de servidores ICE (STUN pÃºblicos para NAT traversal)\r\n        this.iceServers = {\r\n            iceServers: [\r\n                { urls: 'stun:stun.l.google.com:19302' },\r\n                { urls: 'stun:stun1.l.google.com:19302' },\r\n                { urls: 'stun:stun2.l.google.com:19302' }\r\n            ]\r\n        };\r\n\r\n        this.init();\r\n    }\r\n\r\n    init() {\r\n        this.getUsername();\r\n        this.setupEventListeners();\r\n    }\r\n\r\n    getUsername() {\r\n        this.username = prompt('Ingresa tu nombre:') || 'Usuario' + Math.floor(Math.random() * 1000);\r\n        document.getElementById('usernameDisplay').textContent = this.username;\r\n        document.getElementById('userAvatar').textContent = this.username[0].toUpperCase();\r\n        document.getElementById('userAvatar').style.backgroundColor = this.getAvatarColor(this.username);\r\n        this.registerUser();\r\n        this.refreshLists();\r\n        this.connectWebSocket();\r\n    }\r\n\r\n    async registerUser() {\r\n        try {\r\n            const response = await fetch(`${this.API_URL}/register`, {\r\n                method: 'POST',\r\n                headers: { 'Content-Type': 'application/json' },\r\n                body: JSON.stringify({ username: this.username })\r\n            });\r\n            const result = await response.json();\r\n            console.log('Usuario registrado:', result);\r\n        } catch (err) {\r\n            console.error('Error registrando usuario', err);\r\n        }\r\n    }\r\n\r\n    // ConexiÃ³n WebSocket para mensajes en tiempo real\r\n    connectWebSocket() {\r\n        try {\r\n            this.ws = new WebSocket(this.WS_URL);\r\n\r\n            this.ws.onopen = () => {\r\n                console.log('WebSocket conectado');\r\n                this.reconnectAttempts = 0;\r\n                \r\n                // Registrar usuario en el WebSocket\r\n                this.ws.send(JSON.stringify({\r\n                    type: 'register',\r\n                    username: this.username\r\n                }));\r\n                \r\n                this.updateConnectionStatus(true);\r\n            };\r\n\r\n            this.ws.onmessage = (event) => {\r\n                try {\r\n                    const data = JSON.parse(event.data);\r\n                    this.handleWebSocketMessage(data);\r\n                } catch (e) {\r\n                    console.error('Error parseando mensaje WebSocket:', e);\r\n                }\r\n            };\r\n\r\n            this.ws.onclose = () => {\r\n                console.log('WebSocket desconectado');\r\n                this.updateConnectionStatus(false);\r\n                this.attemptReconnect();\r\n            };\r\n\r\n            this.ws.onerror = (error) => {\r\n                console.error('Error WebSocket:', error);\r\n                this.updateConnectionStatus(false);\r\n            };\r\n\r\n        } catch (error) {\r\n            console.error('Error conectando WebSocket:', error);\r\n            this.attemptReconnect();\r\n        }\r\n    }\r\n\r\n    attemptReconnect() {\r\n        if (this.reconnectAttempts < this.maxReconnectAttempts) {\r\n            this.reconnectAttempts++;\r\n            console.log(`Intentando reconexiÃ³n ${this.reconnectAttempts}/${this.maxReconnectAttempts}...`);\r\n            setTimeout(() => this.connectWebSocket(), 2000 * this.reconnectAttempts);\r\n        } else {\r\n            console.log('MÃ¡ximo de intentos de reconexiÃ³n alcanzado');\r\n        }\r\n    }\r\n\r\n    handleWebSocketMessage(data) {\r\n        console.log('Mensaje WebSocket recibido:', data);\r\n\r\n        switch (data.type) {\r\n            case 'registered':\r\n                console.log('Registrado en WebSocket como:', data.username);\r\n                break;\r\n\r\n            case 'newMessage':\r\n                this.handleNewMessage(data.message);\r\n                break;\r\n\r\n            case 'groupCreated':\r\n                console.log('Nuevo grupo creado:', data.groupName);\r\n                this.loadGroups();\r\n                break;\r\n\r\n            case 'incomingCall':\r\n                this.handleIncomingCall(data);\r\n                break;\r\n\r\n            // === WebRTC Signaling ===\r\n            case 'call-offer':\r\n                this.handleCallOffer(data);\r\n                break;\r\n\r\n            case 'call-answer':\r\n                this.handleCallAnswer(data);\r\n                break;\r\n\r\n            case 'ice-candidate':\r\n                this.handleRemoteIceCandidate(data);\r\n                break;\r\n\r\n            case 'call-rejected':\r\n                this.handleCallRejected(data);\r\n                break;\r\n\r\n            case 'call-ended':\r\n                this.handleCallEnded(data);\r\n                break;\r\n\r\n            case 'call-failed':\r\n                this.handleCallFailed(data);\r\n                break;\r\n\r\n            default:\r\n                console.log('Tipo de mensaje no reconocido:', data.type);\r\n        }\r\n    }\r\n\r\n    handleNewMessage(message) {\r\n        // Verificar si el mensaje es relevante para el chat actual\r\n        const isRelevant = this.isMessageRelevant(message);\r\n        \r\n        if (isRelevant) {\r\n            this.displayMessage(message);\r\n        }\r\n        \r\n        // Mostrar notificaciÃ³n si el mensaje no es del usuario actual\r\n        if (message.from !== this.username) {\r\n            this.showNotification(message);\r\n        }\r\n    }\r\n\r\n    isMessageRelevant(message) {\r\n        if (!this.targetUser) return false;\r\n        \r\n        if (message.isGroup) {\r\n            return message.to === this.targetUser;\r\n        } else {\r\n            return (message.from === this.targetUser && message.to === this.username) ||\r\n                   (message.from === this.username && message.to === this.targetUser);\r\n        }\r\n    }\r\n\r\n    showNotification(message) {\r\n        // NotificaciÃ³n en el tÃ­tulo de la pÃ¡gina\r\n        if (document.hidden) {\r\n            document.title = `ðŸ’¬ Nuevo mensaje de ${message.from}`;\r\n            setTimeout(() => {\r\n                document.title = 'Chat App';\r\n            }, 3000);\r\n        }\r\n    }\r\n\r\n    handleIncomingCall(data) {\r\n        // Este mÃ©todo ya no se usa directamente - las llamadas WebRTC usan handleCallOffer\r\n        console.log('handleIncomingCall (legacy):', data);\r\n    }\r\n\r\n    // === WEBRTC: Recibir oferta de llamada ===\r\n    async handleCallOffer(data) {\r\n        const { from, offer, callId, isGroup } = data;\r\n        console.log(`ðŸ“ž Oferta de llamada recibida de ${from}`);\r\n\r\n        // Si ya estamos en una llamada, rechazar\r\n        if (this.isInCall) {\r\n            this.ws.send(JSON.stringify({\r\n                type: 'call-reject',\r\n                to: from,\r\n                callId: callId\r\n            }));\r\n            return;\r\n        }\r\n\r\n        // Mostrar diÃ¡logo de aceptar/rechazar\r\n        const accept = confirm(`ðŸ“ž Llamada entrante de ${from}. Â¿Aceptar?`);\r\n        \r\n        if (!accept) {\r\n            this.ws.send(JSON.stringify({\r\n                type: 'call-reject',\r\n                to: from,\r\n                callId: callId\r\n            }));\r\n            return;\r\n        }\r\n\r\n        try {\r\n            // Aceptar llamada\r\n            this.callPeer = from;\r\n            this.currentCallId = callId;\r\n            this.targetUser = from;\r\n            this.isGroupChat = isGroup || false;\r\n            this.updateChatInterface();\r\n\r\n            // Obtener audio local\r\n            this.localStream = await navigator.mediaDevices.getUserMedia({ \r\n                audio: true, \r\n                video: false \r\n            });\r\n            console.log('âœ“ MicrÃ³fono activado');\r\n\r\n            // Crear PeerConnection\r\n            this.createPeerConnection();\r\n\r\n            // AÃ±adir tracks locales\r\n            this.localStream.getTracks().forEach(track => {\r\n                this.peerConnection.addTrack(track, this.localStream);\r\n            });\r\n\r\n            // Establecer oferta remota\r\n            await this.peerConnection.setRemoteDescription(new RTCSessionDescription(offer));\r\n            console.log('âœ“ Oferta remota establecida');\r\n\r\n            // AÃ±adir candidatos pendientes\r\n            for (const candidate of this.pendingCandidates) {\r\n                await this.peerConnection.addIceCandidate(new RTCIceCandidate(candidate));\r\n            }\r\n            this.pendingCandidates = [];\r\n\r\n            // Crear respuesta\r\n            const answer = await this.peerConnection.createAnswer();\r\n            await this.peerConnection.setLocalDescription(answer);\r\n            console.log('âœ“ Respuesta SDP creada');\r\n\r\n            // Enviar respuesta\r\n            this.ws.send(JSON.stringify({\r\n                type: 'call-answer',\r\n                to: from,\r\n                answer: answer,\r\n                callId: callId\r\n            }));\r\n\r\n            // Iniciar UI de llamada\r\n            this.isInCall = true;\r\n            this.updateCallUI(true);\r\n            this.startCallTimer();\r\n            this.showCallIndicator();\r\n\r\n            this.displayMessage({\r\n                from: from,\r\n                to: this.username,\r\n                message: 'ðŸ“ž Llamada conectada',\r\n                type: 'call',\r\n                timestamp: new Date().toISOString()\r\n            });\r\n\r\n        } catch (error) {\r\n            console.error('Error aceptando llamada:', error);\r\n            alert('Error al aceptar llamada: ' + error.message);\r\n            this.cleanupCall();\r\n        }\r\n    }\r\n\r\n    // === WEBRTC: Recibir respuesta de llamada ===\r\n    async handleCallAnswer(data) {\r\n        const { from, answer } = data;\r\n        console.log(`âœ… Respuesta de llamada recibida de ${from}`);\r\n\r\n        try {\r\n            await this.peerConnection.setRemoteDescription(new RTCSessionDescription(answer));\r\n            console.log('âœ“ Respuesta remota establecida - Llamada conectada!');\r\n\r\n            this.displayMessage({\r\n                from: this.username,\r\n                to: from,\r\n                message: 'ðŸ“ž Llamada conectada',\r\n                type: 'call',\r\n                timestamp: new Date().toISOString()\r\n            });\r\n\r\n        } catch (error) {\r\n            console.error('Error procesando respuesta:', error);\r\n        }\r\n    }\r\n\r\n    // === WEBRTC: Recibir candidato ICE remoto ===\r\n    async handleRemoteIceCandidate(data) {\r\n        const { from, candidate } = data;\r\n\r\n        if (!candidate) return;\r\n\r\n        try {\r\n            if (this.peerConnection && this.peerConnection.remoteDescription) {\r\n                await this.peerConnection.addIceCandidate(new RTCIceCandidate(candidate));\r\n                console.log('âœ“ Candidato ICE aÃ±adido');\r\n            } else {\r\n                // Guardar para despuÃ©s\r\n                this.pendingCandidates.push(candidate);\r\n            }\r\n        } catch (error) {\r\n            console.error('Error aÃ±adiendo candidato ICE:', error);\r\n        }\r\n    }\r\n\r\n    handleCallRejected(data) {\r\n        console.log(`âŒ Llamada rechazada por ${data.from}`);\r\n        alert(`${data.from} rechazÃ³ la llamada`);\r\n        this.cleanupCall();\r\n    }\r\n\r\n    handleCallEnded(data) {\r\n        console.log(`ðŸ“´ Llamada terminada por ${data.from}`);\r\n        \r\n        const reason = data.reason === 'user_disconnected' \r\n            ? 'El usuario se desconectÃ³' \r\n            : 'Llamada finalizada';\r\n        \r\n        this.displayMessage({\r\n            from: data.from,\r\n            to: this.username,\r\n            message: `ðŸ“ž ${reason}`,\r\n            type: 'call',\r\n            timestamp: new Date().toISOString()\r\n        });\r\n\r\n        this.cleanupCall();\r\n    }\r\n\r\n    handleCallFailed(data) {\r\n        console.log(`âŒ Llamada fallida: ${data.reason}`);\r\n        alert(`No se pudo conectar la llamada: ${data.to} no estÃ¡ disponible`);\r\n        this.cleanupCall();\r\n    }\r\n\r\n    updateConnectionStatus(connected) {\r\n        const statusEl = document.getElementById('connectionStatus');\r\n        if (statusEl) {\r\n            statusEl.className = connected ? 'status-connected' : 'status-disconnected';\r\n            statusEl.textContent = connected ? 'â— Conectado' : 'â—‹ Desconectado';\r\n        }\r\n    }\r\n\r\n    async sendMessage() {\r\n        const messageInput = document.getElementById('messageInput');\r\n        const message = messageInput.value.trim();\r\n\r\n        if (message && this.targetUser) {\r\n            try {\r\n                await fetch(`${this.API_URL}/sendMessage`, {\r\n                    method: 'POST',\r\n                    headers: { 'Content-Type': 'application/json' },\r\n                    body: JSON.stringify({\r\n                        from: this.username,\r\n                        to: this.targetUser,\r\n                        message: message,\r\n                        isGroup: this.isGroupChat\r\n                    })\r\n                });\r\n\r\n                messageInput.value = '';\r\n                // El mensaje llegarÃ¡ via WebSocket\r\n            } catch (error) {\r\n                console.error('Error enviando mensaje:', error);\r\n                alert('Error al enviar mensaje: ' + error.message);\r\n            }\r\n        }\r\n    }\r\n\r\n    async sendVoiceNote() {\r\n        if (!this.targetUser) {\r\n            alert('Selecciona un destinatario primero');\r\n            return;\r\n        }\r\n\r\n        console.log('Iniciando grabaciÃ³n de voz...');\r\n\r\n        try {\r\n            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\r\n            console.log('MicrÃ³fono accedido correctamente');\r\n            \r\n            // Detectar el mejor mimeType soportado\r\n            let mimeType = 'audio/webm';\r\n            if (!MediaRecorder.isTypeSupported(mimeType)) {\r\n                mimeType = 'audio/ogg';\r\n                if (!MediaRecorder.isTypeSupported(mimeType)) {\r\n                    mimeType = 'audio/mp4';\r\n                    if (!MediaRecorder.isTypeSupported(mimeType)) {\r\n                        mimeType = ''; // Usar el default del navegador\r\n                    }\r\n                }\r\n            }\r\n            console.log('Usando mimeType:', mimeType || 'default');\r\n            \r\n            const options = mimeType ? { mimeType } : {};\r\n            this.mediaRecorder = new MediaRecorder(stream, options);\r\n            this.audioChunks = [];\r\n            this.currentAudioStream = stream; // Guardar referencia al stream\r\n\r\n            this.mediaRecorder.ondataavailable = (event) => {\r\n                if (event.data.size > 0) {\r\n                    this.audioChunks.push(event.data);\r\n                }\r\n            };\r\n\r\n            this.mediaRecorder.onstop = async () => {\r\n                console.log('GrabaciÃ³n detenida, procesando audio...');\r\n                const audioBlob = new Blob(this.audioChunks, { type: mimeType || 'audio/webm' });\r\n                console.log('Audio blob creado, tamaÃ±o:', audioBlob.size);\r\n                \r\n                // Convertir a Base64\r\n                const reader = new FileReader();\r\n                reader.onloadend = async () => {\r\n                    const base64Audio = reader.result.split(',')[1];\r\n                    console.log('Audio convertido a Base64, longitud:', base64Audio?.length);\r\n                    \r\n                    try {\r\n                        const response = await fetch(`${this.API_URL}/sendVoiceNote`, {\r\n                            method: 'POST',\r\n                            headers: { 'Content-Type': 'application/json' },\r\n                            body: JSON.stringify({\r\n                                from: this.username,\r\n                                to: this.targetUser,\r\n                                audioData: base64Audio,\r\n                                isGroup: this.isGroupChat\r\n                            })\r\n                        });\r\n                        console.log('Nota de voz enviada, respuesta:', response.status);\r\n                    } catch (error) {\r\n                        console.error('Error enviando nota de voz:', error);\r\n                        alert('Error al enviar nota de voz');\r\n                    }\r\n                };\r\n                reader.readAsDataURL(audioBlob);\r\n\r\n                // Detener el stream\r\n                if (this.currentAudioStream) {\r\n                    this.currentAudioStream.getTracks().forEach(track => track.stop());\r\n                    this.currentAudioStream = null;\r\n                }\r\n            };\r\n\r\n            this.mediaRecorder.start();\r\n            this.isRecording = true;\r\n            this.updateRecordingUI(true);\r\n\r\n            // Detener despuÃ©s de 60 segundos mÃ¡ximo\r\n            setTimeout(() => {\r\n                if (this.isRecording) {\r\n                    this.stopRecording();\r\n                }\r\n            }, 60000);\r\n\r\n        } catch (error) {\r\n            console.error('Error accediendo al micrÃ³fono:', error);\r\n            alert('Error al acceder al micrÃ³fono. AsegÃºrate de dar permisos.');\r\n        }\r\n    }\r\n\r\n    stopRecording() {\r\n        if (this.mediaRecorder && this.isRecording) {\r\n            this.mediaRecorder.stop();\r\n            this.isRecording = false;\r\n            this.updateRecordingUI(false);\r\n        }\r\n    }\r\n\r\n    updateRecordingUI(recording) {\r\n        const btn = document.getElementById('voiceNoteBtn');\r\n        if (btn) {\r\n            if (recording) {\r\n                btn.classList.add('recording');\r\n                btn.innerHTML = 'â¹ Detener';\r\n            } else {\r\n                btn.classList.remove('recording');\r\n                btn.innerHTML = 'ðŸŽ¤ Voz';\r\n            }\r\n        }\r\n    }\r\n\r\n    async startCall() {\r\n        console.log('=== startCall (WebRTC) ===');\r\n        console.log('targetUser:', this.targetUser);\r\n        console.log('isInCall:', this.isInCall);\r\n        \r\n        if (!this.targetUser) {\r\n            alert('âš ï¸ Primero selecciona un usuario o grupo para llamar');\r\n            return;\r\n        }\r\n\r\n        if (this.isInCall) {\r\n            console.log('Terminando llamada...');\r\n            this.endCall();\r\n            return;\r\n        }\r\n\r\n        try {\r\n            this.callPeer = this.targetUser;\r\n\r\n            // Obtener audio local\r\n            console.log('Solicitando acceso al micrÃ³fono...');\r\n            this.localStream = await navigator.mediaDevices.getUserMedia({ \r\n                audio: true,\r\n                video: false\r\n            });\r\n            console.log('âœ“ MicrÃ³fono activado');\r\n\r\n            // Crear PeerConnection\r\n            this.createPeerConnection();\r\n\r\n            // AÃ±adir tracks locales al peer connection\r\n            this.localStream.getTracks().forEach(track => {\r\n                this.peerConnection.addTrack(track, this.localStream);\r\n            });\r\n\r\n            // Crear oferta SDP\r\n            const offer = await this.peerConnection.createOffer();\r\n            await this.peerConnection.setLocalDescription(offer);\r\n            console.log('âœ“ Oferta SDP creada');\r\n\r\n            // Enviar oferta via WebSocket\r\n            this.ws.send(JSON.stringify({\r\n                type: 'call-offer',\r\n                to: this.targetUser,\r\n                offer: offer,\r\n                isGroup: this.isGroupChat\r\n            }));\r\n\r\n            console.log('ðŸ“ž Llamando a', this.targetUser);\r\n\r\n            // Iniciar UI de llamada (esperando respuesta)\r\n            this.isInCall = true;\r\n            this.updateCallUI(true);\r\n            this.startCallTimer();\r\n            this.showCallIndicator();\r\n\r\n            this.displayMessage({\r\n                from: this.username,\r\n                to: this.targetUser,\r\n                message: 'ðŸ“ž Llamando...',\r\n                type: 'call',\r\n                timestamp: new Date().toISOString()\r\n            });\r\n\r\n        } catch (error) {\r\n            console.error('Error iniciando llamada:', error);\r\n            \r\n            if (error.name === 'NotAllowedError') {\r\n                alert('âŒ Permiso de micrÃ³fono denegado.');\r\n            } else if (error.name === 'NotFoundError') {\r\n                alert('âŒ No se encontrÃ³ micrÃ³fono.');\r\n            } else {\r\n                alert('âŒ Error al iniciar llamada: ' + error.message);\r\n            }\r\n            this.cleanupCall();\r\n        }\r\n    }\r\n\r\n    // Crear y configurar RTCPeerConnection\r\n    createPeerConnection() {\r\n        console.log('Creando RTCPeerConnection...');\r\n        \r\n        this.peerConnection = new RTCPeerConnection(this.iceServers);\r\n\r\n        // Manejar candidatos ICE locales\r\n        this.peerConnection.onicecandidate = (event) => {\r\n            if (event.candidate) {\r\n                console.log('Candidato ICE local generado');\r\n                this.ws.send(JSON.stringify({\r\n                    type: 'ice-candidate',\r\n                    to: this.callPeer,\r\n                    candidate: event.candidate\r\n                }));\r\n            }\r\n        };\r\n\r\n        // Manejar cambios de estado de conexiÃ³n\r\n        this.peerConnection.onconnectionstatechange = () => {\r\n            console.log('Estado de conexiÃ³n:', this.peerConnection.connectionState);\r\n            \r\n            if (this.peerConnection.connectionState === 'connected') {\r\n                console.log('ðŸŽ‰ ConexiÃ³n WebRTC establecida!');\r\n            } else if (this.peerConnection.connectionState === 'failed' || \r\n                       this.peerConnection.connectionState === 'disconnected') {\r\n                console.log('ConexiÃ³n perdida');\r\n                this.cleanupCall();\r\n            }\r\n        };\r\n\r\n        // Manejar stream remoto (audio del otro usuario)\r\n        this.peerConnection.ontrack = (event) => {\r\n            console.log('ðŸ”Š Stream remoto recibido!');\r\n            this.remoteStream = event.streams[0];\r\n            \r\n            // Reproducir audio remoto\r\n            let remoteAudio = document.getElementById('remoteAudio');\r\n            if (!remoteAudio) {\r\n                remoteAudio = document.createElement('audio');\r\n                remoteAudio.id = 'remoteAudio';\r\n                remoteAudio.autoplay = true;\r\n                document.body.appendChild(remoteAudio);\r\n            }\r\n            remoteAudio.srcObject = this.remoteStream;\r\n            console.log('âœ“ Audio remoto conectado');\r\n        };\r\n\r\n        console.log('âœ“ RTCPeerConnection creado');\r\n    }\r\n\r\n    showCallIndicator() {\r\n        const callIndicator = document.getElementById('callIndicator');\r\n        if (callIndicator) {\r\n            callIndicator.style.display = 'flex';\r\n        }\r\n    }\r\n\r\n    hideCallIndicator() {\r\n        const callIndicator = document.getElementById('callIndicator');\r\n        if (callIndicator) {\r\n            callIndicator.style.display = 'none';\r\n        }\r\n    }\r\n\r\n    startCallTimer() {\r\n        this.callStartTime = Date.now();\r\n        this.callTimerInterval = setInterval(() => {\r\n            const elapsed = Math.floor((Date.now() - this.callStartTime) / 1000);\r\n            const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');\r\n            const seconds = (elapsed % 60).toString().padStart(2, '0');\r\n            const timerEl = document.getElementById('callTimer');\r\n            if (timerEl) {\r\n                timerEl.textContent = `${minutes}:${seconds}`;\r\n            }\r\n        }, 1000);\r\n    }\r\n\r\n    endCall() {\r\n        console.log('=== Terminando llamada WebRTC ===');\r\n        \r\n        // Notificar al otro usuario\r\n        if (this.callPeer && this.ws && this.ws.readyState === WebSocket.OPEN) {\r\n            this.ws.send(JSON.stringify({\r\n                type: 'call-end',\r\n                to: this.callPeer,\r\n                callId: this.currentCallId\r\n            }));\r\n        }\r\n\r\n        // Calcular duraciÃ³n antes de limpiar\r\n        const duration = this.callStartTime \r\n            ? Math.floor((Date.now() - this.callStartTime) / 1000) \r\n            : 0;\r\n        const minutes = Math.floor(duration / 60);\r\n        const seconds = duration % 60;\r\n        const durationStr = `${minutes}:${seconds.toString().padStart(2, '0')}`;\r\n\r\n        // Mostrar mensaje de fin de llamada\r\n        if (this.callPeer) {\r\n            this.displayMessage({\r\n                from: this.username,\r\n                to: this.callPeer,\r\n                message: `ðŸ“ž Llamada finalizada (${durationStr})`,\r\n                type: 'call',\r\n                timestamp: new Date().toISOString()\r\n            });\r\n        }\r\n\r\n        console.log('âœ“ Llamada terminada, duraciÃ³n:', durationStr);\r\n\r\n        this.cleanupCall();\r\n    }\r\n\r\n    // Limpiar todos los recursos de la llamada\r\n    cleanupCall() {\r\n        console.log('Limpiando recursos de llamada...');\r\n\r\n        // Cerrar PeerConnection\r\n        if (this.peerConnection) {\r\n            this.peerConnection.close();\r\n            this.peerConnection = null;\r\n        }\r\n\r\n        // Detener stream local\r\n        if (this.localStream) {\r\n            this.localStream.getTracks().forEach(track => {\r\n                track.stop();\r\n                console.log('Track local detenido:', track.kind);\r\n            });\r\n            this.localStream = null;\r\n        }\r\n\r\n        // Detener stream remoto\r\n        if (this.remoteStream) {\r\n            this.remoteStream.getTracks().forEach(track => track.stop());\r\n            this.remoteStream = null;\r\n        }\r\n\r\n        // Limpiar audio remoto\r\n        const remoteAudio = document.getElementById('remoteAudio');\r\n        if (remoteAudio) {\r\n            remoteAudio.srcObject = null;\r\n        }\r\n\r\n        // Ocultar indicador de llamada\r\n        this.hideCallIndicator();\r\n\r\n        // Detener timer\r\n        if (this.callTimerInterval) {\r\n            clearInterval(this.callTimerInterval);\r\n            this.callTimerInterval = null;\r\n        }\r\n\r\n        // Resetear estado\r\n        this.isInCall = false;\r\n        this.callStartTime = null;\r\n        this.currentCallId = null;\r\n        this.callPeer = null;\r\n        this.pendingCandidates = [];\r\n        this.updateCallUI(false);\r\n\r\n        console.log('âœ“ Recursos de llamada limpiados');\r\n    }\r\n\r\n    updateCallUI(inCall) {\r\n        const btn = document.getElementById('callBtn');\r\n        if (btn) {\r\n            if (inCall) {\r\n                btn.classList.add('in-call');\r\n                btn.innerHTML = 'ðŸ“ž Colgar';\r\n            } else {\r\n                btn.classList.remove('in-call');\r\n                btn.innerHTML = 'ðŸ“ž Llamar';\r\n            }\r\n        }\r\n    }\r\n\r\n    async createGroup() {\r\n        const groupInput = document.getElementById('newGroupName');\r\n        const groupName = groupInput.value.trim();\r\n        \r\n        console.log('createGroup interno llamado, nombre:', groupName);\r\n\r\n        if (groupName) {\r\n            try {\r\n                const response = await fetch(`${this.API_URL}/createGroup`, {\r\n                    method: 'POST',\r\n                    headers: { 'Content-Type': 'application/json' },\r\n                    body: JSON.stringify({ groupName })\r\n                });\r\n                const result = await response.json();\r\n                console.log('Grupo creado, respuesta:', result);\r\n                alert(`Grupo creado: ${groupName}`);\r\n                groupInput.value = '';\r\n                this.loadGroups();\r\n            } catch (error) {\r\n                console.error('Error creando grupo:', error);\r\n                alert('Error al crear grupo: ' + error.message);\r\n            }\r\n        } else {\r\n            alert('Por favor ingresa un nombre para el grupo');\r\n        }\r\n    }\r\n\r\n    selectUser(user) {\r\n        if (user === this.username) return;\r\n        this.targetUser = user;\r\n        this.isGroupChat = false;\r\n        this.updateChatInterface();\r\n        this.loadHistory(user);\r\n    }\r\n\r\n    selectGroup(group) {\r\n        this.targetUser = group;\r\n        this.isGroupChat = true;\r\n        this.updateChatInterface();\r\n        this.loadHistory(group);\r\n    }\r\n\r\n    async loadHistory(target) {\r\n        try {\r\n            const response = await fetch(`${this.API_URL}/getHistory`, {\r\n                method: 'POST',\r\n                headers: { 'Content-Type': 'application/json' },\r\n                body: JSON.stringify({\r\n                    target,\r\n                    from: this.username,\r\n                    isGroup: this.isGroupChat\r\n                })\r\n            });\r\n            \r\n            const result = await response.json();\r\n            \r\n            let messages = [];\r\n            if (result && result.messages) {\r\n                messages = result.messages;\r\n            } else if (Array.isArray(result)) {\r\n                messages = result;\r\n            }\r\n            \r\n            this.displayHistory(messages);\r\n        } catch (error) {\r\n            console.error('Error cargando historial:', error);\r\n        }\r\n    }\r\n\r\n    async refreshLists() {\r\n        await this.loadGroups();\r\n        await this.loadUsers();\r\n    }\r\n\r\n    async loadGroups() {\r\n        try {\r\n            const response = await fetch(`${this.API_URL}/getGroups`, {\r\n                method: 'POST',\r\n                headers: { 'Content-Type': 'application/json' },\r\n                body: JSON.stringify({})\r\n            });\r\n            const result = await response.json();\r\n            let groups = [];\r\n            if (result && result.groups) {\r\n                groups = result.groups;\r\n            } else if (result && Array.isArray(result)) {\r\n                groups = result;\r\n            }\r\n            this.updateGroupList(groups);\r\n        } catch (error) {\r\n            console.error('Error cargando grupos:', error);\r\n        }\r\n    }\r\n\r\n    async loadUsers() {\r\n        try {\r\n            const response = await fetch(`${this.API_URL}/getUsers`, {\r\n                method: 'POST',\r\n                headers: { 'Content-Type': 'application/json' },\r\n                body: JSON.stringify({})\r\n            });\r\n            const result = await response.json();\r\n            let users = [];\r\n            if (result && result.users) {\r\n                users = result.users;\r\n            } else if (result && Array.isArray(result)) {\r\n                users = result;\r\n            }\r\n            this.updateUserList(users);\r\n        } catch (error) {\r\n            console.error('Error cargando usuarios:', error);\r\n        }\r\n    }\r\n\r\n    updateUserList(users) {\r\n        const usersList = document.getElementById('usersList');\r\n        usersList.innerHTML = '';\r\n        users.forEach(user => {\r\n            if (user !== this.username) {\r\n                const el = document.createElement('div');\r\n                el.className = 'user-item';\r\n                if (user === this.targetUser && !this.isGroupChat) {\r\n                    el.classList.add('active');\r\n                }\r\n                el.innerHTML = `\r\n                    <div class=\"avatar\" style=\"background-color: ${this.getAvatarColor(user)}\">\r\n                        ${user[0].toUpperCase()}\r\n                    </div>\r\n                    <span>${user}</span>\r\n                `;\r\n                el.onclick = () => this.selectUser(user);\r\n                usersList.appendChild(el);\r\n            }\r\n        });\r\n    }\r\n\r\n    updateGroupList(groups) {\r\n        const groupsList = document.getElementById('groupsList');\r\n        groupsList.innerHTML = '';\r\n        if (!groups || groups.length === 0) {\r\n            groupsList.innerHTML = '<p style=\"color:#95a5a6;font-size:12px;padding:10px;\">No hay grupos</p>';\r\n            return;\r\n        }\r\n        groups.forEach(group => {\r\n            const el = document.createElement('div');\r\n            el.className = 'group-item';\r\n            if (group === this.targetUser && this.isGroupChat) {\r\n                el.classList.add('active');\r\n            }\r\n            el.innerHTML = `<div class=\"group-avatar\">#</div><span>${group}</span>`;\r\n            el.onclick = () => this.selectGroup(group);\r\n            groupsList.appendChild(el);\r\n        });\r\n    }\r\n\r\n    displayMessage(msg) {\r\n        const container = document.getElementById('messagesContainer');\r\n        if (!container) return;\r\n        \r\n        // Evitar duplicados\r\n        const existingMsgs = container.querySelectorAll('.message');\r\n        for (let i = existingMsgs.length - 1; i >= Math.max(0, existingMsgs.length - 5); i--) {\r\n            const existing = existingMsgs[i];\r\n            if (existing.dataset.from === msg.from && \r\n                existing.dataset.message === (msg.message || msg.content)) {\r\n                return; // Ya existe\r\n            }\r\n        }\r\n        \r\n        const messageEl = this.createMessageElement(msg);\r\n        container.appendChild(messageEl);\r\n        container.scrollTop = container.scrollHeight;\r\n    }\r\n\r\n    displayHistory(messages) {\r\n        const container = document.getElementById('messagesContainer');\r\n        if (!container) return;\r\n        \r\n        container.innerHTML = '';\r\n        if (Array.isArray(messages) && messages.length > 0) {\r\n            messages.forEach(m => {\r\n                try {\r\n                    let msgData = typeof m === 'string' ? JSON.parse(m) : m;\r\n                    if (msgData && msgData.from) {\r\n                        container.appendChild(this.createMessageElement(msgData));\r\n                    }\r\n                } catch (e) {\r\n                    console.error('Error parseando mensaje:', e, m);\r\n                }\r\n            });\r\n        }\r\n        container.scrollTop = container.scrollHeight;\r\n    }\r\n\r\n    createMessageElement(m) {\r\n        const own = m.from === this.username;\r\n        const div = document.createElement('div');\r\n        div.className = `message ${own ? 'right' : 'left'}`;\r\n        div.dataset.from = m.from;\r\n        div.dataset.message = m.message || m.content;\r\n        \r\n        let content = '';\r\n        if (m.type === 'audio' && m.audioData) {\r\n            // Determinar si audioData ya incluye el prefijo o es solo Base64\r\n            let audioSrc = m.audioData;\r\n            if (!audioSrc.startsWith('data:')) {\r\n                audioSrc = `data:audio/webm;base64,${audioSrc}`;\r\n            }\r\n            content = `\r\n                <div class=\"audio-message\">\r\n                    <span class=\"audio-icon\">ðŸŽµ</span>\r\n                    <audio controls>\r\n                        <source src=\"${audioSrc}\" type=\"audio/webm\">\r\n                        Tu navegador no soporta audio.\r\n                    </audio>\r\n                </div>\r\n            `;\r\n        } else if (m.type === 'call') {\r\n            content = `<div class=\"call-message\">ðŸ“ž ${this.escapeHtml(m.message || m.content)}</div>`;\r\n        } else {\r\n            content = `<div class=\"text\">${this.escapeHtml(m.message || m.content)}</div>`;\r\n        }\r\n        \r\n        const timestamp = m.timestamp ? new Date(m.timestamp).toLocaleTimeString() : new Date().toLocaleTimeString();\r\n        \r\n        div.innerHTML = `\r\n            <div class=\"avatar\" style=\"background-color:${this.getAvatarColor(m.from)}\">\r\n                ${m.from[0].toUpperCase()}\r\n            </div>\r\n            <div class=\"text-wrapper\">\r\n                ${!own ? `<div class=\"user-name\">${this.escapeHtml(m.from)}</div>` : ''}\r\n                ${content}\r\n                <div class=\"timestamp\">${timestamp}</div>\r\n            </div>`;\r\n        return div;\r\n    }\r\n\r\n    updateChatInterface() {\r\n        document.getElementById('chatTarget').textContent = this.targetUser;\r\n        document.getElementById('groupBadge').style.display = this.isGroupChat ? 'inline-block' : 'none';\r\n\r\n        const inputWrapper = document.getElementById('messageInputWrapper');\r\n        if (this.targetUser) {\r\n            inputWrapper.style.display = 'flex';\r\n        } else {\r\n            inputWrapper.style.display = 'none';\r\n        }\r\n        \r\n        // Actualizar listas para marcar el seleccionado\r\n        this.loadUsers();\r\n        this.loadGroups();\r\n    }\r\n\r\n    getAvatarColor(u) {\r\n        return this.colors[u.charCodeAt(0) % this.colors.length];\r\n    }\r\n\r\n    escapeHtml(t) {\r\n        if (!t) return '';\r\n        const div = document.createElement('div');\r\n        div.textContent = t;\r\n        return div.innerHTML;\r\n    }\r\n\r\n    setupEventListeners() {\r\n        document.getElementById('messageInput').addEventListener('keypress', e => {\r\n            if (e.key === 'Enter') this.sendMessage();\r\n        });\r\n        \r\n        // Actualizar lista de usuarios periÃ³dicamente (cada 10 segundos)\r\n        setInterval(() => {\r\n            this.loadUsers();\r\n        }, 10000);\r\n    }\r\n}\r\n\r\n// Inicializar la aplicaciÃ³n y exponer funciones globalmente\r\nlet chatApp;\r\n\r\nwindow.onload = () => { \r\n    chatApp = new ChatApp(); \r\n};\r\n\r\n// Exponer funciones al objeto window para que sean accesibles desde el HTML\r\nwindow.sendMessage = function() { \r\n    console.log('sendMessage llamado');\r\n    if (chatApp) chatApp.sendMessage(); \r\n    else console.error('chatApp no inicializado');\r\n};\r\n\r\nwindow.createGroup = function() { \r\n    console.log('createGroup llamado');\r\n    if (chatApp) chatApp.createGroup(); \r\n    else console.error('chatApp no inicializado');\r\n};\r\n\r\nwindow.sendVoiceNote = function() { \r\n    console.log('sendVoiceNote llamado, isRecording:', chatApp?.isRecording);\r\n    if (!chatApp) {\r\n        console.error('chatApp no inicializado');\r\n        return;\r\n    }\r\n    if (chatApp.isRecording) {\r\n        chatApp.stopRecording();\r\n    } else {\r\n        chatApp.sendVoiceNote();\r\n    }\r\n};\r\n\r\nwindow.startCall = function() { \r\n    console.log('startCall llamado');\r\n    if (chatApp) chatApp.startCall(); \r\n    else console.error('chatApp no inicializado');\r\n};\r\n"],"names":["ChatApp","constructor","this","username","targetUser","isGroupChat","colors","API_URL","WS_URL","ws","isRecording","mediaRecorder","audioChunks","isInCall","localStream","remoteStream","reconnectAttempts","maxReconnectAttempts","peerConnection","currentCallId","pendingCandidates","callPeer","iceServers","urls","init","getUsername","setupEventListeners","prompt","Math","floor","random","document","getElementById","textContent","toUpperCase","style","backgroundColor","getAvatarColor","registerUser","refreshLists","connectWebSocket","response","fetch","method","headers","body","JSON","stringify","result","json","console","log","err","error","WebSocket","onopen","send","type","updateConnectionStatus","onmessage","event","data","parse","handleWebSocketMessage","e","onclose","attemptReconnect","onerror","setTimeout","handleNewMessage","message","groupName","loadGroups","handleIncomingCall","handleCallOffer","handleCallAnswer","handleRemoteIceCandidate","handleCallRejected","handleCallEnded","handleCallFailed","isMessageRelevant","displayMessage","from","showNotification","isGroup","to","hidden","title","offer","callId","confirm","updateChatInterface","navigator","mediaDevices","getUserMedia","audio","video","createPeerConnection","getTracks","forEach","track","addTrack","setRemoteDescription","RTCSessionDescription","candidate","addIceCandidate","RTCIceCandidate","answer","createAnswer","setLocalDescription","updateCallUI","startCallTimer","showCallIndicator","timestamp","Date","toISOString","alert","cleanupCall","remoteDescription","push","reason","connected","statusEl","className","sendMessage","messageInput","value","trim","sendVoiceNote","stream","mimeType","MediaRecorder","isTypeSupported","options","currentAudioStream","ondataavailable","size","onstop","async","audioBlob","Blob","reader","FileReader","onloadend","base64Audio","split","length","audioData","status","readAsDataURL","stop","start","updateRecordingUI","stopRecording","recording","btn","classList","add","innerHTML","remove","startCall","endCall","createOffer","name","RTCPeerConnection","onicecandidate","onconnectionstatechange","connectionState","ontrack","streams","remoteAudio","createElement","id","autoplay","appendChild","srcObject","callIndicator","display","hideCallIndicator","callStartTime","now","callTimerInterval","setInterval","elapsed","minutes","toString","padStart","seconds","timerEl","readyState","OPEN","duration","durationStr","close","kind","clearInterval","inCall","createGroup","groupInput","selectUser","user","loadHistory","selectGroup","group","target","messages","Array","isArray","displayHistory","loadUsers","groups","updateGroupList","users","updateUserList","usersList","el","onclick","groupsList","msg","container","existingMsgs","querySelectorAll","i","max","existing","dataset","content","messageEl","createMessageElement","scrollTop","scrollHeight","m","msgData","own","div","audioSrc","startsWith","escapeHtml","toLocaleTimeString","inputWrapper","u","charCodeAt","t","addEventListener","key","chatApp","window","onload"],"ignoreList":[],"sourceRoot":""}