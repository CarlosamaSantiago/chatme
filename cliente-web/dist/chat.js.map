{"version":3,"file":"chat.js","mappings":"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","sources":["webpack://cliente-web/./src/chat.js"],"sourcesContent":["class ChatApp {\r\n    constructor() {\r\n        this.username = '';\r\n        this.targetUser = '';\r\n        this.isGroupChat = false;\r\n        this.colors = [\r\n            '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7',\r\n            '#DDA0DD', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E9'\r\n        ];\r\n        this.ICE_WS_URL = 'ws://localhost:10000';\r\n        this.ws = null;\r\n        this.isRecording = false;\r\n        this.mediaRecorder = null;\r\n        this.audioChunks = [];\r\n        this.isInCall = false;\r\n        this.localStream = null;\r\n        this.remoteStream = null;\r\n        this.pollingInterval = null;\r\n\r\n        this.init();\r\n    }\r\n\r\n    init() {\r\n        this.getUsername();\r\n        this.setupEventListeners();\r\n        // Usar polling en lugar de WebSocket por ahora\r\n        this.startPollingFallback();\r\n    }\r\n\r\n    getUsername() {\r\n        this.username = prompt('Ingresa tu nombre:') || 'Usuario' + Math.floor(Math.random() * 1000);\r\n        document.getElementById('usernameDisplay').textContent = this.username;\r\n        document.getElementById('userAvatar').textContent = this.username[0].toUpperCase();\r\n        document.getElementById('userAvatar').style.backgroundColor = this.getAvatarColor(this.username);\r\n        this.refreshLists();\r\n        this.registerUser();\r\n    }\r\n\r\n    async registerUser() {\r\n        try {\r\n            // Usar Ice RPC para registrar usuario\r\n            const response = await this.callIceRPC('registerUser', { username: this.username });\r\n            console.log('Usuario registrado:', response);\r\n        } catch (err) {\r\n            console.error('Error registrando usuario', err);\r\n        }\r\n    }\r\n\r\n    async callIceRPC(method, params) {\r\n        // Mapear mÃ©todos Ice a endpoints HTTP del proxy\r\n        const endpointMap = {\r\n            'registerUser': '/register',\r\n            'createGroup': '/createGroup',\r\n            'sendMessage': '/sendMessage',\r\n            'sendAudio': '/sendMessage', // Por ahora usar sendMessage\r\n            'startCall': '/sendMessage', // Por ahora usar sendMessage\r\n            'getHistory': '/getHistory',\r\n            'getUsers': '/getUsers',\r\n            'getGroups': '/getGroups'\r\n        };\r\n        \r\n        const endpoint = endpointMap[method] || '/ice/' + method;\r\n        \r\n        try {\r\n            // Adaptar parÃ¡metros segÃºn el endpoint\r\n            let body = params;\r\n            if (method === 'sendMessage') {\r\n                body = {\r\n                    from: params.from,\r\n                    to: params.to,\r\n                    message: params.message || params.content,\r\n                    isGroup: params.isGroup\r\n                };\r\n            } else if (method === 'getHistory') {\r\n                body = {\r\n                    target: params.target,\r\n                    from: params.fromUser,\r\n                    isGroup: params.isGroup\r\n                };\r\n            }\r\n            \r\n            const response = await fetch('http://localhost:3000' + endpoint, {\r\n                method: 'POST',\r\n                headers: { 'Content-Type': 'application/json' },\r\n                body: JSON.stringify(body)\r\n            });\r\n            if (!response.ok) {\r\n                const errorData = await response.json().catch(() => ({ error: 'Error desconocido' }));\r\n                throw new Error(errorData.error || 'Error en la llamada');\r\n            }\r\n            return await response.json();\r\n        } catch (error) {\r\n            console.error('Error en llamada:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    async sendMessage() {\r\n        const messageInput = document.getElementById('messageInput');\r\n        const message = messageInput.value.trim();\r\n\r\n        if (message && this.targetUser) {\r\n            try {\r\n                await this.callIceRPC('sendMessage', {\r\n                    from: this.username,\r\n                    to: this.targetUser,\r\n                    message: message,\r\n                    isGroup: this.isGroupChat\r\n                });\r\n\r\n                // No mostrar el mensaje inmediatamente, esperar a que se cargue del servidor\r\n                messageInput.value = '';\r\n                \r\n                // Recargar historial despuÃ©s de un breve delay\r\n                setTimeout(() => {\r\n                    this.loadHistory(this.targetUser);\r\n                }, 300);\r\n            } catch (error) {\r\n                console.error('Error enviando mensaje:', error);\r\n                alert('Error al enviar mensaje: ' + error.message);\r\n            }\r\n        }\r\n    }\r\n\r\n    async sendVoiceNote() {\r\n        if (!this.targetUser) {\r\n            alert('Selecciona un destinatario primero');\r\n            return;\r\n        }\r\n\r\n        try {\r\n            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\r\n            this.mediaRecorder = new MediaRecorder(stream);\r\n            this.audioChunks = [];\r\n\r\n            this.mediaRecorder.ondataavailable = (event) => {\r\n                if (event.data.size > 0) {\r\n                    this.audioChunks.push(event.data);\r\n                }\r\n            };\r\n\r\n            this.mediaRecorder.onstop = async () => {\r\n                const audioBlob = new Blob(this.audioChunks, { type: 'audio/webm' });\r\n                const arrayBuffer = await audioBlob.arrayBuffer();\r\n                const bytes = new Uint8Array(arrayBuffer);\r\n\r\n                try {\r\n                    await this.callIceRPC('sendAudio', {\r\n                        from: this.username,\r\n                        to: this.targetUser,\r\n                        isGroup: this.isGroupChat,\r\n                        data: Array.from(bytes)\r\n                    });\r\n\r\n                    this.displayMessage({\r\n                        from: this.username,\r\n                        to: this.targetUser,\r\n                        message: '[Nota de voz]',\r\n                        type: 'audio',\r\n                        audioData: bytes,\r\n                        timestamp: new Date().toISOString()\r\n                    });\r\n\r\n                    // Detener el stream\r\n                    stream.getTracks().forEach(track => track.stop());\r\n                } catch (error) {\r\n                    console.error('Error enviando nota de voz:', error);\r\n                    alert('Error al enviar nota de voz');\r\n                }\r\n            };\r\n\r\n            this.mediaRecorder.start();\r\n            this.isRecording = true;\r\n            this.updateRecordingUI(true);\r\n\r\n            // Detener despuÃ©s de 10 segundos o cuando el usuario haga clic de nuevo\r\n            setTimeout(() => {\r\n                if (this.isRecording) {\r\n                    this.stopRecording();\r\n                }\r\n            }, 10000);\r\n\r\n        } catch (error) {\r\n            console.error('Error accediendo al micrÃ³fono:', error);\r\n            alert('Error al acceder al micrÃ³fono');\r\n        }\r\n    }\r\n\r\n    stopRecording() {\r\n        if (this.mediaRecorder && this.isRecording) {\r\n            this.mediaRecorder.stop();\r\n            this.isRecording = false;\r\n            this.updateRecordingUI(false);\r\n        }\r\n    }\r\n\r\n    updateRecordingUI(recording) {\r\n        const btn = document.getElementById('voiceNoteBtn');\r\n        if (btn) {\r\n            if (recording) {\r\n                btn.classList.add('recording');\r\n                btn.textContent = 'â¹ Detener';\r\n            } else {\r\n                btn.classList.remove('recording');\r\n                btn.textContent = 'ðŸŽ¤ Voz';\r\n            }\r\n        }\r\n    }\r\n\r\n    async startCall() {\r\n        if (!this.targetUser) {\r\n            alert('Selecciona un destinatario primero');\r\n            return;\r\n        }\r\n\r\n        if (this.isInCall) {\r\n            this.endCall();\r\n            return;\r\n        }\r\n\r\n        try {\r\n            // Iniciar llamada en el servidor\r\n            await this.callIceRPC('startCall', {\r\n                from: this.username,\r\n                to: this.targetUser,\r\n                isGroup: this.isGroupChat\r\n            });\r\n\r\n            // Obtener acceso a cÃ¡mara y micrÃ³fono\r\n            this.localStream = await navigator.mediaDevices.getUserMedia({ \r\n                video: true, \r\n                audio: true \r\n            });\r\n\r\n            const localVideo = document.getElementById('localVideo');\r\n            if (localVideo) {\r\n                localVideo.srcObject = this.localStream;\r\n                localVideo.style.display = 'block';\r\n            }\r\n\r\n            this.isInCall = true;\r\n            this.updateCallUI(true);\r\n\r\n            // Nota: En una implementaciÃ³n completa, aquÃ­ se establecerÃ­a\r\n            // la conexiÃ³n WebRTC para la llamada\r\n            this.displayMessage({\r\n                from: this.username,\r\n                to: this.targetUser,\r\n                message: '[Llamada iniciada]',\r\n                type: 'call',\r\n                timestamp: new Date().toISOString()\r\n            });\r\n\r\n        } catch (error) {\r\n            console.error('Error iniciando llamada:', error);\r\n            alert('Error al iniciar llamada');\r\n        }\r\n    }\r\n\r\n    endCall() {\r\n        if (this.localStream) {\r\n            this.localStream.getTracks().forEach(track => track.stop());\r\n            this.localStream = null;\r\n        }\r\n\r\n        const localVideo = document.getElementById('localVideo');\r\n        if (localVideo) {\r\n            localVideo.srcObject = null;\r\n            localVideo.style.display = 'none';\r\n        }\r\n\r\n        this.isInCall = false;\r\n        this.updateCallUI(false);\r\n    }\r\n\r\n    updateCallUI(inCall) {\r\n        const btn = document.getElementById('callBtn');\r\n        if (btn) {\r\n            if (inCall) {\r\n                btn.classList.add('in-call');\r\n                btn.textContent = 'ðŸ“ž Colgar';\r\n            } else {\r\n                btn.classList.remove('in-call');\r\n                btn.textContent = 'ðŸ“ž Llamar';\r\n            }\r\n        }\r\n    }\r\n\r\n    async createGroup() {\r\n        const groupInput = document.getElementById('newGroupName');\r\n        const groupName = groupInput.value.trim();\r\n\r\n        if (groupName) {\r\n            try {\r\n                await this.callIceRPC('createGroup', { groupName });\r\n                alert(`Grupo creado: ${groupName}`);\r\n                groupInput.value = '';\r\n                this.loadGroups();\r\n            } catch (error) {\r\n                console.error('Error creando grupo:', error);\r\n                alert('Error al crear grupo');\r\n            }\r\n        }\r\n    }\r\n\r\n    selectUser(user) {\r\n        if (user === this.username) return;\r\n        this.targetUser = user;\r\n        this.isGroupChat = false;\r\n        this.updateChatInterface();\r\n        this.loadHistory(user);\r\n    }\r\n\r\n    selectGroup(group) {\r\n        this.targetUser = group;\r\n        this.isGroupChat = true;\r\n        this.updateChatInterface();\r\n        this.loadHistory(group);\r\n    }\r\n\r\n    async loadHistory(target) {\r\n        try {\r\n            const result = await this.callIceRPC('getHistory', {\r\n                target,\r\n                fromUser: this.username,\r\n                isGroup: this.isGroupChat\r\n            });\r\n            \r\n            // El resultado puede venir en diferentes formatos\r\n            let messages = [];\r\n            if (result && result.messages) {\r\n                messages = result.messages;\r\n            } else if (Array.isArray(result)) {\r\n                messages = result;\r\n            }\r\n            \r\n            this.displayHistory(messages);\r\n        } catch (error) {\r\n            console.error('Error cargando historial:', error);\r\n        }\r\n    }\r\n\r\n    startPollingFallback() {\r\n        // Usar polling para actualizaciones en tiempo real\r\n        if (this.pollingInterval) {\r\n            clearInterval(this.pollingInterval);\r\n        }\r\n        this.pollingInterval = setInterval(() => {\r\n            if (this.targetUser) {\r\n                this.loadHistory(this.targetUser);\r\n            }\r\n            this.refreshLists();\r\n        }, 2000);\r\n    }\r\n    \r\n    stopPolling() {\r\n        if (this.pollingInterval) {\r\n            clearInterval(this.pollingInterval);\r\n            this.pollingInterval = null;\r\n        }\r\n    }\r\n\r\n    async refreshLists() {\r\n        await this.loadGroups();\r\n        await this.loadUsers();\r\n    }\r\n\r\n    async loadGroups() {\r\n        try {\r\n            const result = await this.callIceRPC('getGroups', {});\r\n            let groups = [];\r\n            if (result && result.groups) {\r\n                groups = result.groups;\r\n            } else if (result && Array.isArray(result)) {\r\n                groups = result;\r\n            } else if (result && result.action === 'GROUP_LIST' && result.groups) {\r\n                groups = result.groups;\r\n            }\r\n            this.updateGroupList(groups);\r\n        } catch (error) {\r\n            console.error('Error cargando grupos:', error);\r\n        }\r\n    }\r\n\r\n    async loadUsers() {\r\n        try {\r\n            const result = await this.callIceRPC('getUsers', {});\r\n            let users = [];\r\n            if (result && result.users) {\r\n                users = result.users;\r\n            } else if (result && Array.isArray(result)) {\r\n                users = result;\r\n            }\r\n            this.updateUserList(users);\r\n        } catch (error) {\r\n            console.error('Error cargando usuarios:', error);\r\n        }\r\n    }\r\n\r\n    updateUserList(users) {\r\n        const usersList = document.getElementById('usersList');\r\n        usersList.innerHTML = '';\r\n        users.forEach(user => {\r\n            if (user !== this.username) {\r\n                const el = document.createElement('div');\r\n                el.className = 'user-item';\r\n                el.innerHTML = `\r\n                    <div class=\"avatar\" style=\"background-color: ${this.getAvatarColor(user)}\">\r\n                        ${user[0].toUpperCase()}\r\n                    </div>\r\n                    <span>${user}</span>\r\n                `;\r\n                el.onclick = () => this.selectUser(user);\r\n                usersList.appendChild(el);\r\n            }\r\n        });\r\n    }\r\n\r\n    updateGroupList(groups) {\r\n        const groupsList = document.getElementById('groupsList');\r\n        groupsList.innerHTML = '';\r\n        if (!groups || groups.length === 0) {\r\n            groupsList.innerHTML = '<p style=\"color:#95a5a6;font-size:12px;padding:10px;\">No hay grupos</p>';\r\n            return;\r\n        }\r\n        groups.forEach(group => {\r\n            const el = document.createElement('div');\r\n            el.className = 'group-item';\r\n            el.innerHTML = `<div class=\"group-avatar\">#</div><span>${group}</span>`;\r\n            el.onclick = () => this.selectGroup(group);\r\n            groupsList.appendChild(el);\r\n        });\r\n    }\r\n\r\n    displayMessage(msg) {\r\n        const container = document.getElementById('messagesContainer');\r\n        container.appendChild(this.createMessageElement(msg));\r\n        container.scrollTop = container.scrollHeight;\r\n    }\r\n\r\n    displayHistory(messages) {\r\n        const container = document.getElementById('messagesContainer');\r\n        if (!container) return;\r\n        \r\n        container.innerHTML = '';\r\n        if (Array.isArray(messages) && messages.length > 0) {\r\n            messages.forEach(m => {\r\n                try {\r\n                    let msgData = typeof m === 'string' ? JSON.parse(m) : m;\r\n                    if (msgData && msgData.from) {\r\n                        container.appendChild(this.createMessageElement(msgData));\r\n                    }\r\n                } catch (e) {\r\n                    console.error('Error parseando mensaje:', e, m);\r\n                }\r\n            });\r\n        }\r\n        container.scrollTop = container.scrollHeight;\r\n    }\r\n\r\n    createMessageElement(m) {\r\n        const own = m.from === this.username;\r\n        const div = document.createElement('div');\r\n        div.className = `message ${own ? 'right' : 'left'}`;\r\n        \r\n        let content = '';\r\n        if (m.type === 'audio') {\r\n            content = `\r\n                <div class=\"audio-message\">\r\n                    <audio controls>\r\n                        <source src=\"data:audio/webm;base64,${this.arrayBufferToBase64(m.audioData)}\" type=\"audio/webm\">\r\n                    </audio>\r\n                </div>\r\n            `;\r\n        } else if (m.type === 'call') {\r\n            content = `<div class=\"call-message\">ðŸ“ž ${this.escapeHtml(m.message)}</div>`;\r\n        } else {\r\n            content = `<div class=\"text\">${this.escapeHtml(m.message || m.content)}</div>`;\r\n        }\r\n        \r\n        div.innerHTML = `\r\n            <div class=\"avatar\" style=\"background-color:${this.getAvatarColor(m.from)}\">\r\n                ${m.from[0].toUpperCase()}\r\n            </div>\r\n            <div class=\"text-wrapper\">\r\n                ${!own ? `<div class=\"user-name\">${this.escapeHtml(m.from)}</div>` : ''}\r\n                ${content}\r\n                <div class=\"timestamp\">${m.timestamp ? new Date(m.timestamp).toLocaleTimeString() : new Date().toLocaleTimeString()}</div>\r\n            </div>`;\r\n        return div;\r\n    }\r\n\r\n    arrayBufferToBase64(buffer) {\r\n        if (!buffer) return '';\r\n        const bytes = new Uint8Array(buffer);\r\n        let binary = '';\r\n        for (let i = 0; i < bytes.byteLength; i++) {\r\n            binary += String.fromCharCode(bytes[i]);\r\n        }\r\n        return window.btoa(binary);\r\n    }\r\n\r\n    updateChatInterface() {\r\n        document.getElementById('chatTarget').textContent = this.targetUser;\r\n        document.getElementById('groupBadge').style.display = this.isGroupChat ? 'inline-block' : 'none';\r\n\r\n        const inputWrapper = document.getElementById('messageInputWrapper');\r\n        if (this.targetUser) {\r\n            inputWrapper.style.display = 'flex';\r\n        } else {\r\n            inputWrapper.style.display = 'none';\r\n        }\r\n    }\r\n\r\n    getAvatarColor(u) {\r\n        return this.colors[u.charCodeAt(0) % this.colors.length];\r\n    }\r\n\r\n    escapeHtml(t) {\r\n        const div = document.createElement('div');\r\n        div.textContent = t;\r\n        return div.innerHTML;\r\n    }\r\n\r\n    setupEventListeners() {\r\n        document.getElementById('messageInput').addEventListener('keypress', e => {\r\n            if (e.key === 'Enter') this.sendMessage();\r\n        });\r\n    }\r\n}\r\n\r\nlet chatApp;\r\nwindow.onload = () => { chatApp = new ChatApp(); };\r\nfunction sendMessage() { chatApp.sendMessage(); }\r\nfunction createGroup() { chatApp.createGroup(); }\r\nfunction sendVoiceNote() { \r\n    if (chatApp.isRecording) {\r\n        chatApp.stopRecording();\r\n    } else {\r\n        chatApp.sendVoiceNote();\r\n    }\r\n}\r\nfunction startCall() { chatApp.startCall(); }\r\n\r\n"],"names":["ChatApp","constructor","this","username","targetUser","isGroupChat","colors","ICE_WS_URL","ws","isRecording","mediaRecorder","audioChunks","isInCall","localStream","remoteStream","pollingInterval","init","getUsername","setupEventListeners","startPollingFallback","prompt","Math","floor","random","document","getElementById","textContent","toUpperCase","style","backgroundColor","getAvatarColor","refreshLists","registerUser","response","callIceRPC","console","log","err","error","method","params","endpoint","body","from","to","message","content","isGroup","target","fromUser","fetch","headers","JSON","stringify","ok","errorData","json","catch","Error","sendMessage","messageInput","value","trim","setTimeout","loadHistory","alert","sendVoiceNote","stream","navigator","mediaDevices","getUserMedia","audio","MediaRecorder","ondataavailable","event","data","size","push","onstop","async","audioBlob","Blob","type","arrayBuffer","bytes","Uint8Array","Array","displayMessage","audioData","timestamp","Date","toISOString","getTracks","forEach","track","stop","start","updateRecordingUI","stopRecording","recording","btn","classList","add","remove","startCall","endCall","video","localVideo","srcObject","display","updateCallUI","inCall","createGroup","groupInput","groupName","loadGroups","selectUser","user","updateChatInterface","selectGroup","group","result","messages","isArray","displayHistory","clearInterval","setInterval","stopPolling","loadUsers","groups","action","updateGroupList","users","updateUserList","usersList","innerHTML","el","createElement","className","onclick","appendChild","groupsList","length","msg","container","createMessageElement","scrollTop","scrollHeight","m","msgData","parse","e","own","div","arrayBufferToBase64","escapeHtml","toLocaleTimeString","buffer","binary","i","byteLength","String","fromCharCode","window","btoa","inputWrapper","u","charCodeAt","t","addEventListener","key","chatApp","onload"],"ignoreList":[],"sourceRoot":""}